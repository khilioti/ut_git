////////////////////////////////////////////////////////////////////////////////
// Подсистема "Электронная подпись".
// 
////////////////////////////////////////////////////////////////////////////////

#Область СлужебныйПрограммныйИнтерфейс

// Функция пытается по переданным именам файлов сделать сопоставление
// на файлы данных и файлы их подписей.
// Сопоставление происходит на основе правила формирования имени подписи,
// и расширения файла подписи (p7s).
// Например:
//	Имя файла данных:  "example.txt"
//	имя файла подписи: "example-Ivanov Petr.p7s"
//	имя файла подписи: "example-Ivanov Petr (1).p7s".
//
// Возвращает соответствие, в котором:
// ключ - имя файла
// значение - массив найденных соответствий - подписей.
// 
Функция ПолучитьСоответствиеФайловИПодписей(ИменаФайлов) Экспорт
	
	РасширениеДляФайловПодписи = ЭлектроннаяПодписьКлиентСервер.ПерсональныеНастройки(
		).РасширениеДляФайловПодписи;
	
	Результат = Новый Соответствие;
	
	// Разделяем файлы по расширению.
	ИменаФайловДанных = Новый Массив;
	ИменаФайловПодписей = Новый Массив;
	
	Для Каждого ИмяФайла Из ИменаФайлов Цикл
		Если Прав(ИмяФайла, 3) = РасширениеДляФайловПодписи Тогда
			ИменаФайловПодписей.Добавить(ИмяФайла);
		Иначе
			ИменаФайловДанных.Добавить(ИмяФайла);
		КонецЕсли;
	КонецЦикла;
	
	// Отсортируем имена файлов данных по убыванию числа символов в строке.
	
	Для ИндексА = 1 По ИменаФайловДанных.Количество() Цикл
		ИндексМАКС = ИндексА; // Считаем что текущий файл имеет самое большое число символов.
		Для ИндексБ = ИндексА+1 По ИменаФайловДанных.Количество() Цикл
			Если СтрДлина(ИменаФайловДанных[ИндексМАКС-1]) > СтрДлина(ИменаФайловДанных[ИндексБ-1]) Тогда
				ИндексМАКС = ИндексБ;
			КонецЕсли;
		КонецЦикла;
		своп = ИменаФайловДанных[ИндексА-1];
		ИменаФайловДанных[ИндексА-1] = ИменаФайловДанных[ИндексМАКС-1];
		ИменаФайловДанных[ИндексМАКС-1] = своп;
	КонецЦикла;
	
	// Поиск соответствий имен файлов.
	Для Каждого ИмяФайлаДанных Из ИменаФайловДанных Цикл
		Результат.Вставить(ИмяФайлаДанных, НайтиИменаФайловПодписей(ИмяФайлаДанных, ИменаФайловПодписей));
	КонецЦикла;
	
	// Оставшиеся файлы подписей не распознаны как подписи относящиеся к какому то файлу.
	Для Каждого ИмяФайлаПодписи Из ИменаФайловПодписей Цикл
		Результат.Вставить(ИмяФайлаПодписи, Новый Массив);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Проверяет сертификат. В случае ошибки возвращает описание.
//
// Параметры:
//  МенеджерКриптографии - МенеджерКриптографии - для выполнения проверки.
//  Сертификат           - СертификатКриптографии - сертификат.
//                       - ДвоичныеДанные - двоичные данные сертификата.
//                       - Строка - адрес во временном хранилище с двоичными данными сертификата.
// 
// Возвращаемое значение:
//  Неопределено - ошибки нет.
//  Строка       - описание ошибки проверки сертификата.
// 
Функция ОшибкаПроверкиСертификата(МенеджерКриптографии, Сертификат) Экспорт
	
	СертификатДляПроверки = Сертификат;
	
	Если ТипЗнч(Сертификат) = Тип("Строка") Тогда
		СертификатДляПроверки = ПолучитьИзВременногоХранилища(Сертификат);
	КонецЕсли;
	
	Если ТипЗнч(СертификатДляПроверки) = Тип("ДвоичныеДанные") Тогда
		СертификатДляПроверки = Новый СертификатКриптографии(СертификатДляПроверки);
	КонецЕсли;
	
	МассивРежимовПроверки = Новый Массив;
	МассивРежимовПроверки.Добавить(РежимПроверкиСертификатаКриптографии.ИгнорироватьВремяДействия);
	МассивРежимовПроверки.Добавить(РежимПроверкиСертификатаКриптографии.РазрешитьТестовыеСертификаты);
	
	Попытка
		МенеджерКриптографии.ПроверитьСертификат(СертификатДляПроверки, МассивРежимовПроверки);
	Исключение
		Возврат КраткоеПредставлениеОшибки(ИнформацияОбОшибке());
	КонецПопытки;
	
	Возврат Неопределено;
	
КонецФункции

// Только для внутреннего использования.
Функция МенеджерКриптографии(Программа, ЭтоLinux, Ошибки, ЭтоСервер,
			ПутиКПрограммамНаСерверахLinux = Неопределено) Экспорт
	
	ОписанияПрограмм = ЭлектроннаяПодписьКлиентСервер.ОбщиеНастройки().ОписанияПрограмм;
	
	Если Программа <> Неопределено Тогда
		ПрограммаНеНайдена = Истина;
		Для каждого ОписаниеПрограммы Из ОписанияПрограмм Цикл
			Если ОписаниеПрограммы.Ссылка = Программа Тогда
				ПрограммаНеНайдена = Ложь;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		Если ПрограммаНеНайдена Тогда
			ДобавитьОшибку(Ошибки, Программа, НСтр("ru = 'Не предусмотрена для использования.'"), Истина);
			Возврат Неопределено;
		КонецЕсли;
		ОписанияПрограмм = Новый Массив;
		ОписанияПрограмм.Добавить(ОписаниеПрограммы);
	КонецЕсли;
	
	Менеджер = Неопределено;
	Для каждого ОписаниеПрограммы Из ОписанияПрограмм Цикл
		
		Если Не ЗначениеЗаполнено(ОписаниеПрограммы.ИмяПрограммы) Тогда
			ДобавитьОшибку(Ошибки, ОписаниеПрограммы.Ссылка, НСтр("ru = 'Не указано имя программы.'"), Истина);
			Продолжить;
		КонецЕсли;
		
		Если Не ЗначениеЗаполнено(ОписаниеПрограммы.ТипПрограммы) Тогда
			ДобавитьОшибку(Ошибки, ОписаниеПрограммы.Ссылка, НСтр("ru = 'Не указан тип программы.'"), Истина);
			Продолжить;
		КонецЕсли;
		
		Если ЭтоLinux Тогда
			Если ПутиКПрограммамНаСерверахLinux = Неопределено Тогда
				ПутьКПрограмме = ЭлектроннаяПодписьКлиентСервер.ПерсональныеНастройки(
					).ПутиКПрограммамЭлектроннойПодписиИШифрования.Получить(Программа);
			Иначе
				ПутьКПрограмме = ПутиКПрограммамНаСерверахLinux.Получить(Программа);
			КонецЕсли;
			
			Если Не ЗначениеЗаполнено(ПутьКПрограмме) Тогда
				ДобавитьОшибку(Ошибки, ОписаниеПрограммы.Ссылка,
					НСтр("ru = 'Не предусмотрена для использования.'"), ЭтоСервер, , , Истина);
				Продолжить;
			КонецЕсли;
			
			Попытка
				Менеджер = Новый МенеджерКриптографии(
					ОписаниеПрограммы.ИмяПрограммы,
					ПутьКПрограмме,
					ОписаниеПрограммы.ТипПрограммы);
			Исключение
				ДобавитьОшибку(Ошибки, ОписаниеПрограммы.Ссылка,
					КраткоеПредставлениеОшибки(ИнформацияОбОшибке()), ЭтоСервер, Истина, Истина);
				Продолжить;
			КонецПопытки;
		Иначе
			Попытка
				Менеджер = Новый МенеджерКриптографии(
					ОписаниеПрограммы.ИмяПрограммы,
					"",
					ОписаниеПрограммы.ТипПрограммы);
			Исключение
				ДобавитьОшибку(Ошибки, ОписаниеПрограммы.Ссылка,
					КраткоеПредставлениеОшибки(ИнформацияОбОшибке()), ЭтоСервер, Истина, Истина);
				Продолжить;
			КонецПопытки;
			
			ИмяПрограммыПолученное = Менеджер.ПолучитьИнформациюМодуляКриптографии().Имя;
			Если ИмяПрограммыПолученное <> ОписаниеПрограммы.ИмяПрограммы Тогда
				Менеджер = Неопределено;
				ДобавитьОшибку(Ошибки, ОписаниеПрограммы.Ссылка, СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'Получена другая программа с именем ""%1"".'"), ИмяПрограммыПолученное), ЭтоСервер, Истина);
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		
		АлгоритмПодписи = Строка(ОписаниеПрограммы.АлгоритмПодписи);
		Попытка
			Менеджер.АлгоритмПодписи = АлгоритмПодписи;
		Исключение
			Менеджер = Неопределено;
			// Платформа использует обобщенное сообщение "Неизвестный алгоритм криптографии". Требуется более конкретное.
			ДобавитьОшибку(Ошибки, ОписаниеПрограммы.Ссылка, СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Выбран неизвестный алгоритм подписи ""%1"".'"), АлгоритмПодписи), Истина);
			Продолжить;
		КонецПопытки;
		
		АлгоритмХеширования = Строка(ОписаниеПрограммы.АлгоритмХеширования);
		Попытка
			Менеджер.АлгоритмХеширования = АлгоритмХеширования;
		Исключение
			Менеджер = Неопределено;
			// Платформа использует обобщенное сообщение "Неизвестный алгоритм криптографии". Требуется более конкретное.
			ДобавитьОшибку(Ошибки, ОписаниеПрограммы.Ссылка, СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Выбран неизвестный алгоритм хеширования ""%1"".'"), АлгоритмХеширования), Истина);
			Продолжить;
		КонецПопытки;
		
		АлгоритмШифрования = Строка(ОписаниеПрограммы.АлгоритмШифрования);
		Попытка
			Менеджер.АлгоритмШифрования = АлгоритмШифрования;
		Исключение
			Менеджер = Неопределено;
			// Платформа использует обобщенное сообщение "Неизвестный алгоритм криптографии". Требуется более конкретное.
			ДобавитьОшибку(Ошибки, ОписаниеПрограммы.Ссылка, СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Выбран неизвестный алгоритм шифрования ""%1"".'"), АлгоритмШифрования), Истина);
			Продолжить;
		КонецПопытки;
		
		Прервать; // Требуемый менеджер криптографии получен.
	КонецЦикла;
	
	Возврат Менеджер;
	
КонецФункции

// Только для внутреннего использования.
Функция ПолучитьСертификатПоОтпечатку(МенеджерКриптографии, Отпечаток, ТолькоВЛичномХранилище, ПоказатьОшибку, ОписаниеОшибки) Экспорт
	
	Если ТипЗнч(ТолькоВЛичномХранилище) = Тип("ТипХранилищаСертификатовКриптографии") Тогда
		ТипХранилища = ТолькоВЛичномХранилище;
	ИначеЕсли ТолькоВЛичномХранилище Тогда
		ТипХранилища = ТипХранилищаСертификатовКриптографии.ПерсональныеСертификаты;
	Иначе
		ТипХранилища = Неопределено; // Хранилище, содержащее сертификаты всех доступных типов.
	КонецЕсли;
	
	Попытка
		ХранилищеСертификатов = МенеджерКриптографии.ПолучитьХранилищеСертификатов(ТипХранилища);
	Исключение
		Если ПоказатьОшибку Тогда
			ВызватьИсключение;
		КонецЕсли;
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		ПредставлениеОшибки = КраткоеПредставлениеОшибки(ИнформацияОбОшибке);
	КонецПопытки;
	
	Если Не ЗначениеЗаполнено(ПредставлениеОшибки) Тогда
		Попытка
			ДвоичныеДанныеОтпечатка = Base64Значение(Отпечаток);
		Исключение
			Если ПоказатьОшибку Тогда
				ВызватьИсключение;
			КонецЕсли;
			ИнформацияОбОшибке = ИнформацияОбОшибке();
			ПредставлениеОшибки = КраткоеПредставлениеОшибки(ИнформацияОбОшибке);
		КонецПопытки;
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(ПредставлениеОшибки) Тогда
		Попытка
			Сертификат = ХранилищеСертификатов.НайтиПоОтпечатку(ДвоичныеДанныеОтпечатка);
		Исключение
			Если ПоказатьОшибку Тогда
				ВызватьИсключение;
			КонецЕсли;
			ИнформацияОбОшибке = ИнформацияОбОшибке();
			ПредставлениеОшибки = КраткоеПредставлениеОшибки(ИнформацияОбОшибке);
		КонецПопытки;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ПредставлениеОшибки) Тогда
		Если ТипЗнч(ОписаниеОшибки) = Тип("Структура") Тогда
			ОписаниеОшибки = Новый Структура;
			ОписаниеОшибки.Вставить("ОписаниеОшибки", ОписаниеОшибки);
		Иначе
			ОписаниеОшибки = ПредставлениеОшибки;
		КонецЕсли;
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат Сертификат;
	
КонецФункции

// Только для внутреннего использования.
Процедура ДобавитьСвойстваСертификатовИзХранилища(Таблица, МенеджерКриптографии, Личные, БезОтбора) Экспорт
	
	Если МенеджерКриптографии = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	МассивСертификатов = МенеджерКриптографии.ПолучитьХранилищеСертификатов(
		ТипХранилищаСертификатовКриптографии.ПерсональныеСертификаты).ПолучитьВсе();
	
	Если Не Личные Тогда
		Массив = МенеджерКриптографии.ПолучитьХранилищеСертификатов(
			ТипХранилищаСертификатовКриптографии.СертификатыПолучателей).ПолучитьВсе();
		
		Для каждого Сертификат Из Массив Цикл
			МассивСертификатов.Добавить(Сертификат);
		КонецЦикла;
	КонецЕсли;
	
	#Если ВебКлиент Или ТонкийКлиент Тогда
		ДатаУниверсальная = ОбщегоНазначенияКлиент.ДатаУниверсальная();
	#Иначе
		ДатаУниверсальная = ТекущаяУниверсальнаяДата();
	#КонецЕсли
	
	ОтпечаткиУжеДобавленныхСертификатов = Новый Соответствие; // Для пропуска дублей.
	НаСервере = ТипЗнч(Таблица) <> Тип("Массив");
	
	Для Каждого ТекущийСертификат Из МассивСертификатов Цикл
		Отпечаток = Base64Строка(ТекущийСертификат.Отпечаток);
		
		Если ОтпечаткиУжеДобавленныхСертификатов.Получить(Отпечаток) <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		ОтпечаткиУжеДобавленныхСертификатов.Вставить(Отпечаток);
		
		Если НаСервере Тогда
			Строка = Таблица.Найти(Отпечаток, "Отпечаток");
			Если Строка <> Неопределено Тогда
				Продолжить; // Пропуск уже добавленных на клиенте.
			КонецЕсли;
		КонецЕсли;
		
		Если ТекущийСертификат.ДатаОкончания <= ДатаУниверсальная Тогда
			Если Не БезОтбора Тогда
				Продолжить; // Пропуск просроченных сертификатов.
			КонецЕсли;
		КонецЕсли;
		
		СвойстваСертификата = Новый Структура;
		СвойстваСертификата.Вставить("Отпечаток", Base64Строка(ТекущийСертификат.Отпечаток));
		
		СвойстваСертификата.Вставить("Представление",
			ЭлектроннаяПодписьКлиентСервер.ПредставлениеСертификата(ТекущийСертификат));
		
		СвойстваСертификата.Вставить("КемВыдан",
			ЭлектроннаяПодписьКлиентСервер.ПредставлениеИздателя(ТекущийСертификат));
		
		Если ТипЗнч(Таблица) = Тип("Массив") Тогда
			Таблица.Добавить(СвойстваСертификата);
		Иначе
			Если НаСервере Тогда
				СвойстваСертификата.Вставить("НаСервере", Истина);
			КонецЕсли;
			ЗаполнитьЗначенияСвойств(Таблица.Добавить(), СвойстваСертификата);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Только для внутреннего использования.
Процедура ДобавитьОтпечаткиСертификатовИзЛичногоХранилища(Массив, МенеджерКриптографии) Экспорт
	
	Если МенеджерКриптографии = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	ТипХранилища = ТипХранилищаСертификатовКриптографии.ПерсональныеСертификаты;
	МассивСертификатов = МенеджерКриптографии.ПолучитьХранилищеСертификатов(ТипХранилища).ПолучитьВсе();
	
	#Если ВебКлиент Или ТонкийКлиент Тогда
		ДатаУниверсальная = ОбщегоНазначенияКлиент.ДатаУниверсальная();
	#Иначе
		ДатаУниверсальная = ТекущаяУниверсальнаяДата();
	#КонецЕсли
	
	Для Каждого ТекущийСертификат Из МассивСертификатов Цикл
		Отпечаток = Base64Строка(ТекущийСертификат.Отпечаток);
		
		Если ТекущийСертификат.ДатаОкончания <= ДатаУниверсальная Тогда
			Продолжить; // Пропуск просроченных сертификатов.
		КонецЕсли;
		
		Массив.Добавить(Отпечаток);
	КонецЦикла;
	
КонецПроцедуры

// Только для внутреннего использования.
Функция ПустыеДанныеПодписи(ДанныеПодписи, ОписаниеОшибки) Экспорт
	
	Если Не ЗначениеЗаполнено(ДанныеПодписи) Тогда
		ОписаниеОшибки = НСтр("ru = 'Сформирована пустая подпись.'");
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

// Только для внутреннего использования.
Функция ПустыеЗашифрованныеДанные(ЗашифрованныеДанные, ОписаниеОшибки) Экспорт
	
	Если Не ЗначениеЗаполнено(ЗашифрованныеДанные) Тогда
		ОписаниеОшибки = НСтр("ru = 'Сформированы пустые данные.'");
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

// Только для внутреннего использования.
Функция ПустыеРасшифрованныеДанные(РасшифрованныеДанные, ОписаниеОшибки) Экспорт
	
	Если Не ЗначениеЗаполнено(РасшифрованныеДанные) Тогда
		ОписаниеОшибки = НСтр("ru = 'Сформированы пустые данные.'");
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Вспомогательные процедуры и функции.

// Для функции МенеджерКриптографии.
Процедура ДобавитьОшибку(Ошибки, Программа, Описание, КАдминистратору, Инструкция = Ложь, ИзИсключения = Ложь, НеУказанПуть = Ложь)
	
	СвойстваОшибки = Новый Структура;
	СвойстваОшибки.Вставить("Программа",         Программа);
	СвойстваОшибки.Вставить("Описание",          Описание);
	СвойстваОшибки.Вставить("КАдминистратору",   КАдминистратору);
	СвойстваОшибки.Вставить("Инструкция",        Инструкция);
	СвойстваОшибки.Вставить("ИзИсключения",      ИзИсключения);
	СвойстваОшибки.Вставить("НеУказанПуть",      НеУказанПуть);
	СвойстваОшибки.Вставить("НастройкаПрограмм", Истина);
	
	Ошибки.Добавить(СвойстваОшибки);
	
КонецПроцедуры

// Для функции ПолучитьСоответствиеФайловИПодписей.
Функция НайтиИменаФайловПодписей(ИмяФайлаДанных, ИменаФайловПодписей)
	
	ИменаПодписей = Новый Массив;
	
	Файл = Новый Файл(ИмяФайлаДанных);
	ИмяБезРасширения = Файл.ИмяБезРасширения;
	
	Для Каждого ИмяФайлаПодписи Из ИменаФайловПодписей Цикл
		Если Найти(ИмяФайлаПодписи, ИмяБезРасширения) > 0 Тогда
			ИменаПодписей.Добавить(ИмяФайлаПодписи);
		КонецЕсли;
	КонецЦикла;
	
	Для Каждого ИмяФайлаПодписи Из ИменаПодписей Цикл
		ИменаФайловПодписей.Удалить(ИменаФайловПодписей.Найти(ИмяФайлаПодписи));
	КонецЦикла;
	
	Возврат ИменаПодписей;
	
КонецФункции

#КонецОбласти
